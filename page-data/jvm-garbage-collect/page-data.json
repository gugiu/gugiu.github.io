{"componentChunkName":"component---src-templates-blog-post-js","path":"/jvm-garbage-collect/","result":{"data":{"site":{"siteMetadata":{"title":"GuGiu Blog"}},"markdownRemark":{"id":"6d372e3e-eb07-556c-abb7-224b02c2ef07","excerpt":"Java 虚拟机中的内存分区 区域 介绍 方法区 Method Area -存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  - 线程共享 - 也被很多人认为是 “永久代”，但是后来没有方法区了，变成了 ”元空间“ - 加载器被卸载后，方法区中的 类信息才会被回收 Java…","html":"<h3>Java 虚拟机中的内存分区</h3>\n<table>\n<thead>\n<tr>\n<th>区域</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方法区 Method Area</td>\n<td>-存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 <br/> - 线程共享 - 也被很多人认为是 “永久代”，但是后来没有方法区了，变成了 ”元空间“ <br/>- 加载器被卸载后，方法区中的 类信息才会被回收</td>\n</tr>\n<tr>\n<td><strong>Java 堆</strong></td>\n<td>- 存储大多数对象<br/>- 线程共享<br/>- 分为新生代老年代，新生代又分为 Eden 区和 Survivor 区<br/>垃圾回收主要是回收这个区</td>\n</tr>\n<tr>\n<td>虚拟机栈</td>\n<td>创建栈帧 存储局部变量、操作数栈、动态链接、方法出口等</td>\n</tr>\n<tr>\n<td>本地方法栈</td>\n<td>与虚拟机栈作用类似</td>\n</tr>\n<tr>\n<td>程序计数器 Program Counter Register</td>\n<td>当前线程执行的字节码的行号指示器</td>\n</tr>\n</tbody>\n</table>\n<h3>判断对象是否需要回收的算法</h3>\n<h4>引用计数算法</h4>\n<p>Java 没有选用，其他语言有选用的，比如Python。Java 没有选用的主要原因是很难解决循环引用。</p>\n<h4>可达性分析算法</h4>\n<p>当一个对象到 GC Roots 没有任何引用链相联，则认为该对象不可用。</p>\n<h4>关于引用</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强引用</td>\n<td>宁愿OOM也不回收</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>GC时会把有用非必需的对象回收</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>无论是否有用，内存是否紧张都会被回收</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>垃圾收集算法</h3>\n<ul>\n<li>标记清除算法</li>\n<li>复制算法</li>\n<li>标记整理算法</li>\n</ul>\n<p><code class=\"language-text\">安全点</code></p>\n<p><code class=\"language-text\">安全区域</code></p>\n<h4>垃圾收集器</h4>\n<ul>\n<li>Serial 收集器</li>\n<li>ParNew 收集器</li>\n<li>Parallel Scavenhge</li>\n<li>Serial Old 收集器</li>\n<li>\n<p>CMS 收集器</p>\n<ul>\n<li>服务器常用</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>CPU 资源敏感</li>\n<li>无法处理浮动垃圾 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>G1 收集器</p>\n<ul>\n<li>分相同大小的区域</li>\n<li>优点\n- 内存分配与回收策略\n- 对象优先在 新生代的 Eden 分配</li>\n</ul>\n</li>\n</ul>\n<h2>FAQ</h2>\n<h4>1. G1 相比 CMS 优势 ?</h4>\n<p>空间整合，不会产生内存空间碎片\n可预测停顿</p>\n<h4>2. 什么是 GC Root ？</h4>\n<p><a href=\"https://help.eclipse.org/2020-06/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&#x26;cp=37_2_3\">https://help.eclipse.org/2020-06/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&#x26;cp=37_2_3</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Garbage Collection Roots\nA garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root:\n\nSystem Class\nClass loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .\nJNI Local\nLocal variable in native code, such as user defined JNI code or JVM internal code.\nJNI Global\nGlobal variable in native code, such as user defined JNI code or JVM internal code.\nThread Block\nObject referred to from a currently active thread block.\nThread\nA started, but not stopped, thread.\nBusy Monitor\nEverything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.\nJava Local\nLocal variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.\nNative Stack\nIn or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.\nFinalizable\nAn object which is in a queue awaiting its finalizer to be run.\nUnfinalized\nAn object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.\nUnreachable\nAn object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.\nJava Stack Frame\nA Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.\nUnknown\nAn object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</code></pre></div>\n<h4>3. finalize</h4>\n<p>finalize()只会被系统自动调用一次。下次回收时不会再调用 finalize 方法，则对象会被回收，</p>","frontmatter":{"title":"JVM 垃圾收集器与内存分配策略","date":"July 16, 2020","description":"JVM 垃圾收集器与内存分配策略"}}},"pageContext":{"slug":"/jvm-garbage-collect/","previous":null,"next":null}}}